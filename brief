/*

class RMP{
    constructor(object){
        this.addressValueMapping = new Map();
    }

    couple(message1, message2, message1.name, message2.friends[2]){

    }
}

export default RMP

let message1 = {
    name:"maaz",
    age: 21,
    friends:["aalu","gobi","dip jain"]
}

["messageid","name"] => hashValue 

is value a value or a reference...
if(currentObject.@rmpref)

let message2 = {
    name:"dip",
    age: 21,
    friends:["aalu","gobi",
        {
            @rmpref:hashValue
        }
    ]
}

console.log(message1.name === message2.friends[2])


let someobject = {
    _rmpref_:"value"
}
console.log(someobject.$abc)

let parse(message, currentAddress = [message.id]){
    if(!message)return;

    for (const [key, value] of Object.entries(obj)){
        currentAddress = currentAddress + "" + key
        hash = getHash(currentAddress);
        let defprom = this.hashPromiseMapping.get(hash);
        defprom.resolve(value);
        this.hashValueMapping.set(hash, value)
        this.pathValueMapping.set(hash, value)
        this.

        Map
        key -> String,Number, object-> get(key) object value, object reference
        JSON.stringify(path);


        if(value is null){
            return;
        }

        if(value && value._rmmpref_){
            //check in the buffer if the value exists

        }

        if(value is array){
            iterate array
            traverse(item)
        }

        if(value is object){
            traverse(object)
        }
    }
}
getDeferredPromise() {
        let resolve, reject;
        const promise = new Promise((res, rej) => {
            resolve = res;
            reject = rej;
        });
        return {
            promise,
            resolve,
            reject
        };
    }

resolve(reference){
    if(Map.has(reference._rmmpref_)){
        if(reference){
            return resolve(reference)
        }if(value){
            return value
        }
    }else{
        let defprom = getDeferredPromise();
        this.addressPromiseMapping.set(reference._rmpref_, defprom)
        return defprom.promise
    }
}

get()

await resolve()

EVENT LOOP thread

HEAP: VALUE: value

CALL STACK []
TASK QUEUE []

seprate thread/ process BROWSER RUNTIME/ NODEJS/ BUN/ DENO [new Promise((res, rej)=>{
    //something something
})]

non blocking

hello there

console.log(new Promise((res, rej)=>{
        rej(10);
    }).catch(()=>{
    console.log("rejected")
}))


let p = new Promise((res, rej)=>{
    setTimeout(()=>{res(10)},10000)
})

console.log(await p)

*/


// {
//     communicationHeader:{
            // label:"ACK",
            // id:

//     }
//     protocolHeader:{
//         label:"MSG",
//         version:1
//         bypass:false,
//         id:nuvndivnriuvhru
//     }
//     payload:{

//     }
// }